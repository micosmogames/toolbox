/*
 *  method.js
 *
 *  Runtime decoraters to explicitly define and uplift functions as methods.
 *
 *  Supports a coding policy that limits the use of 'this' to well defined method functions.
 *  These include object literal property function definitions, module functions declared as methods or
 *  module functions promoted to methods.
 *  All other function definitions should not reference 'this', other than arrow functions that are
 *  defined within the body of a method.
 *
 */
"use strict";

module.exports = {
  asDeclaredMethod,
  declareMethod,
  isaDeclaredMethod,
  method
};

// Promotes a non-method function to pass 'this' as the first parameter. The function is assumed to interact with
// an object that is accepted as the first argument. The returned function
// is wrapped to check that a valid 'this' has been passed. Can be attached directly to a property
// of an object although is inefficient so unwrapping either by setting the property to f.method,
// or method(f). Note that latter is preferred as it is not dependent on how the method has been
// constructed.
function asDeclaredMethod(f) {
  if (f.method)
    throw new Error('asDeclaredMethod: Function is already a method');
  const fMeth = function (...args) {
    if (!this)
      throw new Error('asDeclaredMethod: Attempting to call a method as a function. Require object dot notation, bound function or function call');
    return f(this, ...args);
  }
  fMeth.method = function (...args) {
    return f(this, ...args);
  };
  return fMeth;
}

// Explicit declaration that a function is actually a method that references 'this'. The returned function
// is wrapped to check that a valid 'this' has been passed. Can be attached directly to a property
// of an object although is inefficient so unwrapping either by setting the property to f.method,
// or method(f). Note that latter is preferred as it is not dependent on how the method has been
// constructed.
function declareMethod(f) {
  if (f.method)
    throw new Error('declareMethod: Function is already a method');
  const fMeth = function (...args) {
    if (!this)
      throw new Error('declareMethod: Attempting to call a method as a function. Require object dot notation, bound function or function call');
    return f.call(this, ...args);
  };
  fMeth.method = f;
  return fMeth;
}

function isaDeclaredMethod(f) {
  return typeof f.method === 'function'
}

// The method decorator is intended to explicitly define that the function being assigned to an object property
// must be a method. For declared or promoted methods fMeth.method function (undeclared instance) is returned,
// otherwise an implicitly promoted instance of the function is returned.
// Can be called at anytime, but it should be noted that the result is the undeclared method.
function method(f) {
  if (!f)
    throw new Error(`method: Function has not been defined. Possible call to 'method' before 'declareMethod'`);
  if (f.method)
    return f.method;
  return function (...args) {
    return f(this, ...args);
  }
}
