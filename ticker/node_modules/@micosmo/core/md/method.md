# @micosmo/core/method

The *this* keyword in Javascript is a common root cause to many programming errors. The main reason is the implicit binding of *this* only occurs when a non arrow function property of an object is invoked as a method. By method we mean that the function is referenced by the object '.' notation in the call expression. At any other time *this* will only be valid if a function (property or direct function reference) is either bound (*bind* call) or is called using the *call* function property and passing the target *this* as the first parameter.

One way of reducing programming errors and mitigating the impact of incorrect use of functions that reference *this* is to implement a programming policy that limits the use of 'this' to explicitly defined methods. Explicit methods are:

1. Function definitions that are explicitly defined within the body of an object literal. If such definitons reference *this* then they are assumed to be a method. Inline object literal function definitions that do not reference *this* are assumed to be normal functions assigned to a property of the object.
2. Function definitions that are defined outside of the body of an object literal that are explcitly declared as a method. Such definitions can be assigned to object properties and behave as a method. See *declareMethod* decorator function.
3. Normal functions that accept a target object as the first parameter and are explicitly promoted to a method and assigned to an object property. See *asDeclaredMethod* decorator function.

## API

### IMPORTING

```javascript
const { asDeclaredMethod, declareMethod, method } = require('@micosmo/core/method');
```

### EXPORTS

Function | Description
-------- | -----------
asDeclaredMethod(f) | Returns a method function that wraps a normal function that is assumed to accept a target object as the first argument. The promoted function passes *this* as the first parameter of *f*. The method function ensures that there is a valid *this* binding. This resultant function can only be invoked via the object dot notation, after creating a bound function or issuing a function *call*. The *f* function is assigned to the *method* property of the returned function. The returned function is a *declared* method.
declareMethod(f) | Returns a method function that ensures that there is a valid *this* binding. This resultant function can only be invoked via the object dot notation, after creating a bound function or issuing a function *call*. The *f* function is assigned to the *method* property of the returned function. The returned function is a *declared* method.
isaDeclaredMethod | Returns a boolean indicating if the function is a *declared* method.
method(f) | Returns a method function that expects a *this* binding. In this case the returned method function is in it's *undeclared* form. In other words the declared method wrapper is removed along with the error checking. If *f* is not a *declared* method then *f* is promoted to a method and the *undeclared* form is returned. Typically *method* will be employed to assign external methods to object properties, both as a means of explicitly defining the property as a method as well as assigning the most efficient form of the method.

### EXAMPLE

```javascript
const { asDeclaredMethod, declareMethod, method } = require('@micosmo/core/method');

const meth1 = declareMethod(function () {
  console.log('meth1: Object Name =', this.name);
});

const meth2 = asDeclaredMethod(function (o) {
  console.log('meth2: Object Name =', o.name);
});

function meth3(o) {
  console.log('meth3: Object Name =', o.name);
};

const foobar = {
  name: 'foobar',
  meth1: method(meth1), // Unwrap declared method
  meth2: method(meth2), // Unwrap declared method and return promoted method
  meth3: method(meth3) // Implicitly promote the function to a method
}

foobar.meth1();
/*
  meth1: Object Name = foobar
*/
foobar.meth2();
/*
  meth2: Object Name = foobar
*/
foobar.meth3();
/*
  meth3: Object Name = foobar
*/
```

### NOTES

If we have a *declared* method *f* then *f* can be directly invoked by *f.method.call(o, ...)* instead of *f.call(o, ...)*. This avoids the overhead of the *declared* method wrapper. Alternatively we can use *method(f).call(o, ...)* which will also avoid the *declared* method wrapper but will promote *f* if *f* is not a *declared* method.

## LICENSE

ISC - Internet Systems Consortium

Copyright 2019 Micosmo ([www.micosmo.com](http://www.micosmo.com))

Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
